# The Waveshare ESP32-P4-WIFI6-my_touchscreen-LCD-7B is a self contained, 7 inch 1024x600 touchscreen display with an ESP32-P4 MCU.
# It has an ESP32-C6 co-processor that gives the P4 Wi-Fi capabilities.
#
# Schematic: https://files.waveshare.com/wiki/ESP32-P4-WIFI6-Touch-LCD-7B/ESP32-P4-WIFI6-Touch-LCD-7B.pdf
---
esphome:
  name: waveshare-esp32-p4-touch-lcd-7b
  friendly_name: waveshare-esp32-p4-wifi6-touch-lcd-7b

external_components:
  - source: github://pr#11886
    components: [mipi_dsi]
    refresh: 1h

esp32:
  variant: esp32p4
  flash_size: 16MB
  cpu_frequency: 360MHz
  framework:
    type: esp-idf
    advanced:
      enable_idf_experimental_features: true

esp32_hosted:
  variant: ESP32C6
  reset_pin: GPIO54
  cmd_pin: GPIO19
  clk_pin: GPIO18
  d0_pin: GPIO14
  d1_pin: GPIO15
  d2_pin: GPIO16
  d3_pin: GPIO17
  active_high: true

psram:
  mode: hex
  speed: 200MHz

preferences:
  flash_write_interval: 5min

esp_ldo:
  - voltage: 2.5V
    channel: 3

# -------------------------------------------
# Touchscreen gt911 i2c
# -------------------------------------------
i2c:
  - id: bus_a
    sda: GPIO07
    scl: GPIO08
    frequency: 400kHz

touchscreen:
  - platform: gt911
    id: my_touchscreen
    i2c_id: bus_a
    reset_pin: GPIO23
    update_interval: 50ms
    transform:
      swap_xy: false
      mirror_x: false
      mirror_y: false
      # on_touch:
            # - logger.log:
            # format: Touch at (%d, %d)
            # args: [touch.x, touch.y]
            # - lambda: |-
                # ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
                # touch.x,
                # touch.y,
                # touch.x_raw,
                # touch.y_raw
                # );

# -------------------------------------------
# Backlight
# -------------------------------------------
output:
  - platform: ledc
    id: gpio_backlight_pwm
    pin: GPIO32
    inverted: true
    frequency: 1000Hz

light:
  - platform: monochromatic
    output: gpio_backlight_pwm
    name: Display Backlight
    icon: mdi:lightbulb-on
    id: display_backlight
    restore_mode: ALWAYS_ON
    default_transition_length: 250ms

# -------------------------------------------
# Display
# -------------------------------------------
display:
  - platform: mipi_dsi
    id: my_display
    model: WAVESHARE-ESP32-P4-WIFI6-TOUCH-LCD-7B
    rotation: 180
    update_interval: never
    auto_clear_enabled: false
    dimensions:
      width: 1024
      height: 600

# LVGL settings required for this display
lvgl:
  buffer_size: 100%
  byte_order: little_endian

# -------------------------------------------
# Audio
# -------------------------------------------
# NS4150B Power amplifier control - keeping from working example
switch:
  - platform: gpio
    pin: GPIO53
    id: power_amplifier_control
    name: "Power Amplifier Control"
    inverted: false
    restore_mode: ALWAYS_ON

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: GPIO10
    i2s_bclk_pin: GPIO12
    i2s_mclk_pin: GPIO13

audio_adc:
  - platform: es7210
    id: es7210_adc
    bits_per_sample: 16bit
    sample_rate: 16000

microphone:
  - platform: i2s_audio
    id: microphone_id
    i2s_din_pin: GPIO11
    sample_rate: 16000
    bits_per_sample: 16bit
    adc_type: external
    channel: stereo

audio_dac:
  - platform: es8311
    id: es8311_dac

speaker:
  - platform: i2s_audio
    id: speaker_id
    i2s_dout_pin: GPIO09
    dac_type: external
    channel: mono
    buffer_duration: 100ms
    bits_per_sample: 16bit
    sample_rate: 48000

media_player:
  - platform: speaker
    name: None
    id: media_player_id
    announcement_pipeline:
      speaker: speaker_id
      format: FLAC
      sample_rate: 48000
      num_channels: 1
    on_announcement:
      # Stop the wake word (mWW or VA) if the mic is capturing
      - if:
          condition:
            - microphone.is_capturing:
          then:
            - micro_wake_word.stop:
    on_idle:
      # Since VA isn't running, this is the end of user-intiated media playback. Restart the wake word.
      - if:
          condition:
            not:
              voice_assistant.is_running:
          then:
            - micro_wake_word.start:

micro_wake_word:
  id: mww
  models:
    - okay_nabu
    - hey_mycroft
    - hey_jarvis
  on_wake_word_detected:
    - voice_assistant.start:
        wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: microphone_id
  media_player: media_player_id
  micro_wake_word: mww
  on_end:
    # Wait a short amount of time to see if an announcement starts
    - wait_until:
        condition:
          - media_player.is_announcing:
        timeout: 0.5s
    # Announcement is finished and the I2S bus is free
    - wait_until:
        - and:
            - not:
                media_player.is_announcing:
            - not:
                speaker.is_playing:
    - micro_wake_word.start:
  on_client_connected:
    - micro_wake_word.start:
  on_client_disconnected:
    - micro_wake_word.stop:  