---
# ═══════════════════════════════════════════════════════════════════════════════
# NOAA TIDE UPDATE - Direct API Integration
# ═══════════════════════════════════════════════════════════════════════════════
# Fetches tide prediction data directly from the NOAA CO-OPS API.
#
# NOAA API: https://api.tidesandcurrents.noaa.gov/api/prod/
#
# Required vars:
#   noaa_station_id: Your NOAA station ID (e.g., "9414290" for San Francisco)
#                    Find yours at: https://tidesandcurrents.noaa.gov/map/
#
# Optional vars:
#   noaa_unit_system: "english" or "metric" (default: "english")
#                     The display unit label ("ft" or "m") is derived
#                     automatically from this setting.
#
# Note: ESP32 timezone should match the NOAA station's timezone for
#       correct local time display. Epoch comparisons are timezone-safe.
#
# Usage in your main config:
#   packages:
#     tide_info: !include
#       file: esphome-modular-lvgl-buttons/NOAA_tides/NOAA_tide_update.yaml
#       vars:
#         noaa_station_id: "9414290"
#         noaa_unit_system: "english"   # or "metric"
# ═══════════════════════════════════════════════════════════════════════════════

# Defaults for optional vars (used when not provided by the caller)
defaults:
  noaa_unit_system: english

# -------------------------------------------
# Global Variables
# -------------------------------------------
# Store tide prediction data for percentage calculations
globals:
  - id: noaa_unit_label
    type: const char * const
    restore_value: false
    initial_value: '"${noaa_unit_system}" == std::string("metric") ? "m" : "ft"'
  - id: noaa_last_tide_epoch
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: noaa_next_tide_epoch
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: noaa_next_tide_is_high
    type: bool
    restore_value: false
    initial_value: 'false'

# -------------------------------------------
# Graphics and Fonts
# -------------------------------------------
image:
  rgb565:
    alpha_channel:
      - file: esphome-modular-lvgl-buttons/NOAA_tides/assets/images/tide_pointer.svg
        id: tide_pointer
        resize: 200x88

      - file: esphome-modular-lvgl-buttons/NOAA_tides/assets/images/high_tide.svg
        id: high_tide
        resize: 29x32

      - file: esphome-modular-lvgl-buttons/NOAA_tides/assets/images/low_tide.svg
        id: low_tide
        resize: 29x32

font:
  - file: "gfonts://Roboto@700"
    id: roboto30_bold
    size: 30
    bpp: 8

# -------------------------------------------
# Sensors (Template - populated from NOAA API)
# -------------------------------------------
sensor:
  # Tide percentage: 0=just after high tide heading to low,
  #   50=at low tide, 100=at high tide
  # Recalculates every 60 seconds from stored epoch values
  - platform: template
    name: "Tide Percentage"
    id: tide_percentage
    accuracy_decimals: 1
    update_interval: 60s
    lambda: |-
      time_t last_e = id(noaa_last_tide_epoch);
      time_t next_e = id(noaa_next_tide_epoch);
      if (last_e == 0 || next_e == 0 || next_e <= last_e) return NAN;

      time_t now_e = id(system_time).now().timestamp;
      float period = (float)(next_e - last_e);
      float elapsed = (float)(now_e - last_e);
      float ratio = elapsed / period;
      if (ratio < 0.0f) ratio = 0.0f;
      if (ratio > 1.0f) ratio = 1.0f;

      // 0→50 = heading to low tide, 50→100 = heading to high tide
      float base = id(noaa_next_tide_is_high) ? 50.0f : 0.0f;
      return base + (ratio * 50.0f);
    on_value:
      then:
        - lvgl.indicator.update:
            id: tide_level
            value: !lambda "return id(tide_percentage).state;"

  - platform: template
    name: "High Tide Level"
    id: high_tide_level
    accuracy_decimals: 2
    update_interval: never
    on_value:
      then:
        - lvgl.label.update:
            id: high_tide_height
            text:
              format: "%.2f %s"
              args: ['id(high_tide_level).state', 'id(noaa_unit_label)']

  - platform: template
    name: "Low Tide Level"
    id: low_tide_level
    accuracy_decimals: 2
    update_interval: never
    on_value:
      then:
        - lvgl.label.update:
            id: low_tide_height
            text:
              format: "%.2f %s"
              args: ['id(low_tide_level).state', 'id(noaa_unit_label)']

  # Mean High Water and Mean Low Water (relative to MLLW datum)
  # Fetched once on boot from NOAA Metadata API - these values rarely change
  - platform: template
    name: "Mean High Water"
    id: mean_high_water
    accuracy_decimals: 2
    update_interval: never

  - platform: template
    name: "Mean Low Water"
    id: mean_low_water
    accuracy_decimals: 2
    update_interval: never

# -------------------------------------------
# Text Sensors
# -------------------------------------------
text_sensor:
  - platform: template
    name: "High Tide Time"
    id: high_tide_time_sensor
    update_interval: never
    on_value:
      then:
        - lvgl.label.update:
            id: high_tide_label
            text:
              format: "%s"
              args: ['id(high_tide_time_sensor).state.c_str()']

  - platform: template
    name: "Low Tide Time"
    id: low_tide_time_sensor
    update_interval: never
    on_value:
      then:
        - lvgl.label.update:
            id: low_tide_label
            text:
              format: "%s"
              args: ['id(low_tide_time_sensor).state.c_str()']

# -------------------------------------------
# Scripts
# -------------------------------------------
# Extend on_ha_connected script (called from loading_480px.yaml when HA connects)
script:
  - id: !extend on_ha_connected
    then:
      # Delay to avoid colliding with other action calls at startup
      - delay: 5s
      - script.execute: fetch_noaa_datums
      - script.execute: fetch_noaa_tides

  # Fetch tidal datums (MLW, MHW) from NOAA Metadata API
  # These are station constants that don't change, so only fetched once on boot.
  # Values are converted from station datum (STND) to MLLW to match predictions.
  # API docs: https://api.tidesandcurrents.noaa.gov/mdapi/prod/
  - id: fetch_noaa_datums
    then:
      - logger.log:
          level: INFO
          format: "Fetching NOAA tidal datums for station ${noaa_station_id}..."
      - http_request.get:
          capture_response: true
          max_response_buffer_size: 3072
          url: "https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations/${noaa_station_id}/datums.json?units=${noaa_unit_system}"
          on_response:
            then:
              - lambda: |-
                  if (response->status_code != 200) {
                    ESP_LOGE("noaa", "NOAA Datums API returned HTTP %d", response->status_code);
                    return;
                  }
                  if (body.length() == 0) {
                    ESP_LOGE("noaa", "Empty response from NOAA Datums API");
                    return;
                  }

                  ESP_LOGD("noaa", "Got %d bytes from NOAA Datums API", body.length());

                  // Parse JSON: {"datums": [{"name": "MHW", "value": 8.78}, ...]}
                  // Values are relative to station datum (STND).
                  // Subtract MLLW to convert to the same datum used by tide predictions.
                  json::parse_json(body, [](JsonObject root) -> bool {
                    if (!root["datums"].is<JsonArray>()) {
                      ESP_LOGE("noaa", "Datums response missing 'datums' key");
                      return false;
                    }

                    JsonArray datums = root["datums"];
                    float mllw = NAN, mlw = NAN, mhw = NAN;

                    for (JsonObject datum : datums) {
                      const char* name = datum["name"];
                      if (!name) continue;
                      float val = datum["value"].as<float>();

                      if (strcmp(name, "MLLW") == 0) mllw = val;
                      else if (strcmp(name, "MLW") == 0) mlw = val;
                      else if (strcmp(name, "MHW") == 0) mhw = val;
                    }

                    if (std::isnan(mllw) || std::isnan(mlw) || std::isnan(mhw)) {
                      ESP_LOGE("noaa", "Could not find required datums (MLLW/MLW/MHW)");
                      return false;
                    }

                    // Convert from station datum to MLLW datum
                    float mlw_mllw = mlw - mllw;
                    float mhw_mllw = mhw - mllw;

                    id(mean_low_water).publish_state(mlw_mllw);
                    id(mean_high_water).publish_state(mhw_mllw);

                    ESP_LOGI("noaa", "Tidal datums (relative to MLLW): MLW=%.2f, MHW=%.2f",
                      mlw_mllw, mhw_mllw);

                    return true;
                  });

  # Main script: Fetch tide predictions from NOAA CO-OPS API
  - id: fetch_noaa_tides
    then:
      - if:
          condition:
            lambda: 'return id(system_time).now().is_valid();'
          then:
            - logger.log:
                level: INFO
                format: "Fetching NOAA tide predictions for station ${noaa_station_id}..."
            - http_request.get:
                capture_response: true
                max_response_buffer_size: 2048
                url: !lambda |-
                  // Build URL with date range: yesterday through tomorrow
                  // This ensures we always capture the most recent past tide
                  // and the next upcoming tide, even near midnight.
                  auto now = id(system_time).now();
                  time_t now_epoch = now.timestamp;
                  time_t yesterday_epoch = now_epoch - 86400;
                  time_t tomorrow_epoch = now_epoch + 86400;
                  struct tm yesterday_tm, tomorrow_tm;
                  localtime_r(&yesterday_epoch, &yesterday_tm);
                  localtime_r(&tomorrow_epoch, &tomorrow_tm);
                  char begin_buf[9], end_buf[9];
                  strftime(begin_buf, sizeof(begin_buf), "%Y%m%d", &yesterday_tm);
                  strftime(end_buf, sizeof(end_buf), "%Y%m%d", &tomorrow_tm);
                  char url[350];
                  snprintf(url, sizeof(url),
                    "https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?"
                    "begin_date=%s&end_date=%s"
                    "&station=${noaa_station_id}"
                    "&product=predictions&datum=MLLW&interval=hilo"
                    "&time_zone=lst_ldt&units=${noaa_unit_system}"
                    "&application=ESPHome&format=json",
                    begin_buf, end_buf);
                  ESP_LOGD("noaa", "Request URL: %s", url);
                  return std::string(url);
                on_response:
                  then:
                    - lambda: |-
                        if (response->status_code != 200) {
                          ESP_LOGE("noaa", "NOAA API returned HTTP %d", response->status_code);
                          return;
                        }
                        if (body.length() == 0) {
                          ESP_LOGE("noaa", "Empty response from NOAA API");
                          return;
                        }

                        ESP_LOGD("noaa", "Got %d bytes from NOAA API", body.length());

                        // Parse the NOAA JSON response
                        // Format: {"predictions": [{"t":"YYYY-MM-DD HH:MM", "v":"1.234", "type":"H"}, ...]}
                        json::parse_json(body, [](JsonObject root) -> bool {
                          if (!root["predictions"].is<JsonArray>()) {
                            ESP_LOGE("noaa", "Response missing 'predictions' key - check station ID");
                            return false;
                          }

                          JsonArray predictions = root["predictions"];
                          if (predictions.size() == 0) {
                            ESP_LOGE("noaa", "Empty predictions array");
                            return false;
                          }

                          ESP_LOGD("noaa", "Parsing %d tide predictions", predictions.size());

                          time_t now_epoch = id(system_time).now().timestamp;

                          // Track the most recent past tide and the first future tide
                          time_t best_last_epoch = 0;
                          float best_last_level = 0;
                          bool best_last_is_high = false;

                          time_t best_next_epoch = 0;
                          float best_next_level = 0;
                          bool best_next_is_high = false;
                          bool found_next = false;

                          for (JsonObject prediction : predictions) {
                            const char* t = prediction["t"];
                            const char* v = prediction["v"];
                            const char* type_str = prediction["type"];
                            if (!t || !v || !type_str) continue;

                            // Parse time: "YYYY-MM-DD HH:MM"
                            int yr, mo, dy, hr, mn;
                            if (sscanf(t, "%d-%d-%d %d:%d", &yr, &mo, &dy, &hr, &mn) != 5) {
                              ESP_LOGW("noaa", "Failed to parse time: %s", t);
                              continue;
                            }
                            struct tm tm_time = {};
                            tm_time.tm_year = yr - 1900;
                            tm_time.tm_mon = mo - 1;
                            tm_time.tm_mday = dy;
                            tm_time.tm_hour = hr;
                            tm_time.tm_min = mn;
                            tm_time.tm_isdst = -1;
                            time_t pred_epoch = mktime(&tm_time);

                            float level = atof(v);
                            bool is_high = (strcmp(type_str, "H") == 0);

                            if (pred_epoch <= now_epoch) {
                              if (pred_epoch > best_last_epoch) {
                                best_last_epoch = pred_epoch;
                                best_last_level = level;
                                best_last_is_high = is_high;
                              }
                            } else if (!found_next) {
                              best_next_epoch = pred_epoch;
                              best_next_level = level;
                              best_next_is_high = is_high;
                              found_next = true;
                            }
                          }

                          if (!found_next || best_last_epoch == 0) {
                            ESP_LOGW("noaa", "Could not determine last/next tide from predictions");
                            return false;
                          }

                          // Store epochs for tide_percentage calculation
                          id(noaa_last_tide_epoch) = best_last_epoch;
                          id(noaa_next_tide_epoch) = best_next_epoch;
                          id(noaa_next_tide_is_high) = best_next_is_high;

                          // Format epoch to "10:58 AM" (strip leading zero)
                          auto fmt_time = [](time_t epoch) -> std::string {
                            struct tm tm;
                            localtime_r(&epoch, &tm);
                            char buf[16];
                            strftime(buf, sizeof(buf), "%I:%M %p", &tm);
                            return std::string(buf[0] == '0' ? buf + 1 : buf);
                          };

                          // Publish to high/low sensors (on_value triggers LVGL updates)
                          if (best_next_is_high) {
                            id(high_tide_level).publish_state(best_next_level);
                            id(low_tide_level).publish_state(best_last_level);
                            id(high_tide_time_sensor).publish_state(fmt_time(best_next_epoch));
                            id(low_tide_time_sensor).publish_state(fmt_time(best_last_epoch));
                          } else {
                            id(low_tide_level).publish_state(best_next_level);
                            id(high_tide_level).publish_state(best_last_level);
                            id(low_tide_time_sensor).publish_state(fmt_time(best_next_epoch));
                            id(high_tide_time_sensor).publish_state(fmt_time(best_last_epoch));
                          }

                          ESP_LOGI("noaa", "Last tide: %s at %ld (%.2f)",
                            best_last_is_high ? "High" : "Low", (long)best_last_epoch, best_last_level);
                          ESP_LOGI("noaa", "Next tide: %s at %ld (%.2f)",
                            best_next_is_high ? "High" : "Low", (long)best_next_epoch, best_next_level);

                          // Recalculate tide percentage
                          id(tide_percentage).update();

                          return true;
                        });
          else:
            - logger.log:
                level: WARN
                format: "Time not yet synced - skipping NOAA tide fetch"

# -------------------------------------------
# Periodic Refresh
# -------------------------------------------
# Check every 5 minutes whether a re-fetch is needed.
# Only makes an API call when data is stale or next tide is < 3 hours away.
interval:
  - interval: 5min
    then:
      - if:
          condition:
            lambda: |-
              // Skip if time isn't synced yet
              if (!id(system_time).now().is_valid()) return false;
              // Always fetch if we have no data
              time_t next_e = id(noaa_next_tide_epoch);
              if (next_e == 0) return true;
              // Re-fetch if next tide has already passed (data is stale)
              time_t now_e = id(system_time).now().timestamp;
              if (now_e >= next_e) return true;
              // Re-fetch if next tide is less than 3 hours away
              // (ensures we get fresh data for the tide after that)
              return (next_e - now_e) < 10800;
          then:
            - script.execute: fetch_noaa_tides
