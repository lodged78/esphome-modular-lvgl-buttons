---
# ═══════════════════════════════════════════════════════════════════════════════
# NOAA TIDE UPDATE - Direct API Integration
# ═══════════════════════════════════════════════════════════════════════════════
# Fetches tide prediction data directly from the NOAA CO-OPS API.
#
# NOAA API: https://api.tidesandcurrents.noaa.gov/api/prod/
#
# Required substitutions (define in your main config):
#   noaa_station_id: Your NOAA station ID (e.g., "9414290" for San Francisco)
#                    Find yours at: https://tidesandcurrents.noaa.gov/map/
#
# Optional substitutions:
#   noaa_unit_system: "english" or "metric" (default: "english")
#
# Note: ESP32 timezone should match the NOAA station's timezone for
#       correct local time display. Epoch comparisons are timezone-safe.
#
# Usage in your main config:
#   substitutions:
#     noaa_station_id: "9414290"
#     noaa_unit_system: "english"
#   packages:
#     noaa_tides: !include esphome-modular-lvgl-buttons/NOAA_tides/NOAA_tide_update.yaml
# ═══════════════════════════════════════════════════════════════════════════════

# Provide defaults for optional substitutions
substitutions:
  noaa_unit_system: english

# -------------------------------------------
# HTTP Request Component
# -------------------------------------------
http_request:
  useragent: "ESPHome/NOAA-Tides"
  timeout: 10s

# -------------------------------------------
# Global Variables
# -------------------------------------------
# Store tide prediction data for percentage calculations
globals:
  - id: noaa_last_tide_epoch
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: noaa_next_tide_epoch
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: noaa_next_tide_is_high
    type: bool
    restore_value: false
    initial_value: 'false'

# -------------------------------------------
# Graphics and Fonts
# -------------------------------------------
image:
  rgb565:
    alpha_channel:
      - file: esphome-modular-lvgl-buttons/tides/assets/images/tide_pointer.svg
        id: tide_pointer
        resize: 200x88

      - file: esphome-modular-lvgl-buttons/tides/assets/images/high_tide.svg
        id: high_tide
        resize: 29x32

      - file: esphome-modular-lvgl-buttons/tides/assets/images/low_tide.svg
        id: low_tide
        resize: 29x32

font:
  - file: "gfonts://Roboto@700"
    id: roboto30_bold
    size: 30
    bpp: 8

# -------------------------------------------
# Sensors (Template - populated from NOAA API)
# -------------------------------------------
sensor:
  # Tide percentage: 0=just after high tide heading to low,
  #   50=at low tide, 100=at high tide
  # Recalculates every 60 seconds from stored epoch values
  - platform: template
    name: "Tide Percentage"
    id: tide_percentage
    accuracy_decimals: 1
    update_interval: 60s
    lambda: |-
      time_t last_e = id(noaa_last_tide_epoch);
      time_t next_e = id(noaa_next_tide_epoch);
      if (last_e == 0 || next_e == 0 || next_e <= last_e) return NAN;

      time_t now_e = id(system_time).now().timestamp;
      float period = (float)(next_e - last_e);
      float elapsed = (float)(now_e - last_e);
      float ratio = elapsed / period;
      if (ratio < 0.0f) ratio = 0.0f;
      if (ratio > 1.0f) ratio = 1.0f;

      // Match logic from custom_components/noaa_tides/sensor.py
      if (id(noaa_next_tide_is_high)) {
        // Heading toward high tide: percentage goes 50 → 100
        return (ratio * 50.0f) + 50.0f;
      } else {
        // Heading toward low tide: percentage goes 0 → 50
        return ratio * 50.0f;
      }
    on_value:
      then:
        - lvgl.indicator.update:
            id: tide_level
            value: !lambda "return id(tide_percentage).state;"

  - platform: template
    name: "Next Tide Level"
    id: next_tide_level
    accuracy_decimals: 2
    update_interval: never

  - platform: template
    name: "Last Tide Level"
    id: last_tide_level
    accuracy_decimals: 2
    update_interval: never

# -------------------------------------------
# Text Sensors (Template - populated from NOAA API)
# -------------------------------------------
text_sensor:
  - platform: template
    name: "Next Tide Type"
    id: next_tide_type
    update_interval: never

  - platform: template
    name: "Next Tide Time"
    id: next_tide_time
    update_interval: never
    on_value:
      - if:
          condition:
            text_sensor.state:
              id: next_tide_type
              state: 'Low'
          then:
            - lvgl.label.update:
                id: low_tide_label
                text:
                  format: "%s"
                  args: ['id(next_tide_time).state.c_str()']
            - lvgl.label.update:
                id: low_tide_height
                text:
                  format: "%.2f %s"
                  args: ['id(next_tide_level).state', '(strcmp("${noaa_unit_system}", "metric") == 0) ? "m" : "ft"']
          else:
            - lvgl.label.update:
                id: high_tide_label
                text:
                  format: "%s"
                  args: ['id(next_tide_time).state.c_str()']
            - lvgl.label.update:
                id: high_tide_height
                text:
                  format: "%.2f %s"
                  args: ['id(next_tide_level).state', '(strcmp("${noaa_unit_system}", "metric") == 0) ? "m" : "ft"']

  - platform: template
    name: "Last Tide Type"
    id: last_tide_type
    update_interval: never

  - platform: template
    name: "Last Tide Time"
    id: last_tide_time
    update_interval: never
    on_value:
      - if:
          condition:
            text_sensor.state:
              id: last_tide_type
              state: 'Low'
          then:
            - lvgl.label.update:
                id: low_tide_label
                text:
                  format: "%s"
                  args: ['id(last_tide_time).state.c_str()']
            - lvgl.label.update:
                id: low_tide_height
                text:
                  format: "%.2f %s"
                  args: ['id(last_tide_level).state', '(strcmp("${noaa_unit_system}", "metric") == 0) ? "m" : "ft"']
          else:
            - lvgl.label.update:
                id: high_tide_label
                text:
                  format: "%s"
                  args: ['id(last_tide_time).state.c_str()']
            - lvgl.label.update:
                id: high_tide_height
                text:
                  format: "%.2f %s"
                  args: ['id(last_tide_level).state', '(strcmp("${noaa_unit_system}", "metric") == 0) ? "m" : "ft"']

# -------------------------------------------
# Scripts
# -------------------------------------------
# Extend on_ha_connected script (called from loading_480px.yaml when HA connects)
script:
  - id: !extend on_ha_connected
    then:
      # Delay to avoid colliding with other action calls at startup
      - delay: 5s
      - script.execute: fetch_noaa_tides

  # Main script: Fetch tide predictions from NOAA CO-OPS API
  - id: fetch_noaa_tides
    then:
      - if:
          condition:
            lambda: 'return id(system_time).now().is_valid();'
          then:
            - logger.log:
                level: INFO
                format: "Fetching NOAA tide predictions for station ${noaa_station_id}..."
            - http_request.get:
                capture_response: true
                max_response_buffer_size: 2048
                url: !lambda |-
                  // Build URL with date range: yesterday through tomorrow
                  // This ensures we always capture the most recent past tide
                  // and the next upcoming tide, even near midnight.
                  auto now = id(system_time).now();
                  time_t now_epoch = now.timestamp;
                  time_t yesterday_epoch = now_epoch - 86400;
                  time_t tomorrow_epoch = now_epoch + 86400;
                  struct tm yesterday_tm, tomorrow_tm;
                  localtime_r(&yesterday_epoch, &yesterday_tm);
                  localtime_r(&tomorrow_epoch, &tomorrow_tm);
                  char begin_buf[9], end_buf[9];
                  strftime(begin_buf, sizeof(begin_buf), "%Y%m%d", &yesterday_tm);
                  strftime(end_buf, sizeof(end_buf), "%Y%m%d", &tomorrow_tm);
                  char url[350];
                  snprintf(url, sizeof(url),
                    "https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?"
                    "begin_date=%s&end_date=%s"
                    "&station=${noaa_station_id}"
                    "&product=predictions&datum=MLLW&interval=hilo"
                    "&time_zone=lst_ldt&units=${noaa_unit_system}"
                    "&application=ESPHome&format=json",
                    begin_buf, end_buf);
                  ESP_LOGD("noaa", "Request URL: %s", url);
                  return std::string(url);
                on_response:
                  then:
                    - lambda: |-
                        if (status_code != 200) {
                          ESP_LOGE("noaa", "NOAA API returned HTTP %d", status_code);
                          return;
                        }
                        if (body.length() == 0) {
                          ESP_LOGE("noaa", "Empty response from NOAA API");
                          return;
                        }

                        ESP_LOGD("noaa", "Got %d bytes from NOAA API", body.length());

                        // Parse the NOAA JSON response
                        // Format: {"predictions": [{"t":"YYYY-MM-DD HH:MM", "v":"1.234", "type":"H"}, ...]}
                        json::parse_json(body, [](JsonObject root) -> bool {
                          if (!root.containsKey("predictions")) {
                            ESP_LOGE("noaa", "Response missing 'predictions' key - check station ID");
                            return false;
                          }

                          JsonArray predictions = root["predictions"];
                          if (predictions.size() == 0) {
                            ESP_LOGE("noaa", "Empty predictions array");
                            return false;
                          }

                          ESP_LOGD("noaa", "Parsing %d tide predictions", predictions.size());

                          time_t now_epoch = id(system_time).now().timestamp;

                          // Track the most recent past tide and the first future tide
                          time_t best_last_epoch = 0;
                          float best_last_level = 0;
                          bool best_last_is_high = false;
                          std::string best_last_time_str;

                          time_t best_next_epoch = 0;
                          float best_next_level = 0;
                          bool best_next_is_high = false;
                          std::string best_next_time_str;
                          bool found_next = false;

                          for (JsonObject prediction : predictions) {
                            const char* t = prediction["t"];       // "YYYY-MM-DD HH:MM"
                            const char* v = prediction["v"];       // Water level string
                            const char* type_str = prediction["type"];  // "H" or "L"

                            if (!t || !v || !type_str) continue;

                            // Parse time: "YYYY-MM-DD HH:MM"
                            int yr, mo, dy, hr, mn;
                            if (sscanf(t, "%d-%d-%d %d:%d", &yr, &mo, &dy, &hr, &mn) != 5) {
                              ESP_LOGW("noaa", "Failed to parse time: %s", t);
                              continue;
                            }
                            struct tm tm_time = {};
                            tm_time.tm_year = yr - 1900;
                            tm_time.tm_mon = mo - 1;
                            tm_time.tm_mday = dy;
                            tm_time.tm_hour = hr;
                            tm_time.tm_min = mn;
                            tm_time.tm_sec = 0;
                            tm_time.tm_isdst = -1;  // Let mktime determine DST
                            time_t pred_epoch = mktime(&tm_time);

                            float level = atof(v);
                            bool is_high = (strcmp(type_str, "H") == 0);

                            // Format display time: "10:58 AM" (strip leading zero)
                            char time_buf[16];
                            strftime(time_buf, sizeof(time_buf), "%I:%M %p", &tm_time);
                            std::string formatted_time;
                            if (time_buf[0] == '0') {
                              formatted_time = std::string(time_buf + 1);
                            } else {
                              formatted_time = std::string(time_buf);
                            }

                            if (pred_epoch <= now_epoch) {
                              // Past or current tide - keep the most recent one
                              if (pred_epoch > best_last_epoch) {
                                best_last_epoch = pred_epoch;
                                best_last_level = level;
                                best_last_is_high = is_high;
                                best_last_time_str = formatted_time;
                              }
                            } else if (!found_next) {
                              // First future tide
                              best_next_epoch = pred_epoch;
                              best_next_level = level;
                              best_next_is_high = is_high;
                              best_next_time_str = formatted_time;
                              found_next = true;
                            }
                          }

                          if (!found_next || best_last_epoch == 0) {
                            ESP_LOGW("noaa", "Could not determine last/next tide from predictions");
                            return false;
                          }

                          // Store epochs for ongoing tide_percentage calculation
                          id(noaa_last_tide_epoch) = best_last_epoch;
                          id(noaa_next_tide_epoch) = best_next_epoch;
                          id(noaa_next_tide_is_high) = best_next_is_high;

                          // Publish to template sensors
                          std::string last_type = best_last_is_high ? "High" : "Low";
                          std::string next_type = best_next_is_high ? "High" : "Low";

                          id(last_tide_type).publish_state(last_type);
                          id(next_tide_type).publish_state(next_type);
                          id(last_tide_time).publish_state(best_last_time_str);
                          id(next_tide_time).publish_state(best_next_time_str);
                          id(last_tide_level).publish_state(best_last_level);
                          id(next_tide_level).publish_state(best_next_level);

                          ESP_LOGI("noaa", "Last tide: %s at %s (%.2f)",
                            last_type.c_str(), best_last_time_str.c_str(), best_last_level);
                          ESP_LOGI("noaa", "Next tide: %s at %s (%.2f)",
                            next_type.c_str(), best_next_time_str.c_str(), best_next_level);

                          // Force immediate tide percentage recalculation
                          id(tide_percentage).update();

                          return true;
                        });
          else:
            - logger.log:
                level: WARN
                format: "Time not yet synced - skipping NOAA tide fetch"

# -------------------------------------------
# Periodic Refresh
# -------------------------------------------
# Check every 5 minutes whether a re-fetch is needed.
# Only makes an API call when data is stale or next tide is < 3 hours away.
interval:
  - interval: 5min
    then:
      - if:
          condition:
            lambda: |-
              // Skip if time isn't synced yet
              if (!id(system_time).now().is_valid()) return false;
              // Always fetch if we have no data
              time_t next_e = id(noaa_next_tide_epoch);
              if (next_e == 0) return true;
              // Re-fetch if next tide has already passed (data is stale)
              time_t now_e = id(system_time).now().timestamp;
              if (now_e >= next_e) return true;
              // Re-fetch if next tide is less than 3 hours away
              // (ensures we get fresh data for the tide after that)
              return (next_e - now_e) < 10800;
          then:
            - script.execute: fetch_noaa_tides
